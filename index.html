<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Writing Defense Platform</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            max-width: 1600px;
            margin: 0 auto;
            background: white;
        }
        
        /* Header */
        .header {
            grid-column: 1 / -1;
            background: #1a1a2e;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 24px;
            justify-content: space-between;
            border-bottom: 3px solid #16213e;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .logo-icon {
            width: 36px;
            height: 36px;
            background: #e94560;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
        }
        
        .status-badge {
            background: #0f3460;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .status-badge.ready { background: #16c79a; color: #1a1a2e; }
        .status-badge.pending { background: #f9a825; color: #1a1a2e; }
        
        /* Sidebars */
        .sidebar-left, .sidebar-right {
            background: #f8f9fa;
            border-right: 1px solid #e0e0e0;
            overflow-y: auto;
            padding: 20px;
        }
        
        .sidebar-right {
            border-right: none;
            border-left: 1px solid #e0e0e0;
        }
        
        /* Main Content */
        .main-content {
            display: flex;
            flex-direction: column;
            background: white;
        }
        
        .toolbar {
            padding: 12px 24px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            gap: 12px;
            align-items: center;
            background: #fafafa;
        }
        
        .toolbar button {
            padding: 6px 12px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .toolbar button:hover {
            background: #f0f0f0;
            border-color: #999;
        }
        
        .editor-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #editor {
            width: 100%;
            height: 100%;
            padding: 40px;
            font-family: 'Georgia', serif;
            font-size: 16px;
            line-height: 1.8;
            color: #333;
            border: none;
            outline: none;
            resize: none;
            overflow-y: auto;
        }
        
        #editor:empty:before {
            content: "Start writing here... Your Shadow scores will appear in real-time as you type.";
            color: #999;
            font-style: italic;
        }
        
        /* Cards */
        .card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #e0e0e0;
        }
        
        .card h3 {
            font-size: 13px;
            font-weight: 600;
            color: #555;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .metric:last-child { border-bottom: none; }
        
        .metric-value {
            font-size: 20px;
            font-weight: 700;
            color: #1a1a2e;
        }
        
        .metric-value.warning { color: #e94560; }
        .metric-value.success { color: #16c79a; }
        .metric-value.caution { color: #f9a825; }
        
        .progress-bar {
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #e94560;
            transition: width 0.3s;
            border-radius: 3px;
        }
        
        .progress-fill.safe { background: #16c79a; }
        .progress-fill.caution { background: #f9a825; }
        
        /* Shadow Chart */
        .shadow-chart {
            display: flex;
            align-items: flex-end;
            height: 100px;
            gap: 3px;
            margin-top: 12px;
        }
        
        .shadow-bar {
            flex: 1;
            background: #e0e0e0;
            border-radius: 2px 2px 0 0;
            min-height: 5px;
            transition: all 0.3s;
            position: relative;
        }
        
        .shadow-bar:hover {
            opacity: 0.8;
            cursor: pointer;
        }
        
        .shadow-bar.high { background: #e94560; }
        .shadow-bar.medium { background: #f9a825; }
        .shadow-bar.low { background: #16c79a; }
        
        .shadow-bar.current {
            box-shadow: 0 0 0 2px #1a1a2e;
            z-index: 10;
        }
        
        /* Burstiness EKG */
        .ekg-container {
            height: 80px;
            background: #fafafa;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            margin-top: 12px;
        }
        
        #ekgCanvas {
            width: 100%;
            height: 100%;
        }
        
        /* Stumbles */
        .stumble-list {
            max-height: 150px;
            overflow-y: auto;
            font-size: 12px;
        }
        
        .stumble-item {
            padding: 8px;
            background: #fff3cd;
            border-left: 3px solid #f9a825;
            margin-bottom: 6px;
            border-radius: 0 4px 4px 0;
            color: #856404;
        }
        
        /* Upload Area */
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 12px;
        }
        
        .upload-area:hover {
            border-color: #e94560;
            background: #fff5f5;
        }
        
        .upload-area input {
            display: none;
        }
        
        /* Alerts */
        .alerts-container {
            position: fixed;
            top: 80px;
            right: 24px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .alert {
            padding: 12px 20px;
            background: white;
            border-left: 4px solid #e94560;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-radius: 0 8px 8px 0;
            font-size: 13px;
            max-width: 300px;
            animation: slideIn 0.3s ease;
        }
        
        .alert.warning { border-left-color: #f9a825; }
        .alert.success { border-left-color: #16c79a; }
        .alert.info { border-left-color: #3b82f6; }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            width: 90%;
            max-width: 500px;
            border-radius: 12px;
            padding: 32px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .modal h2 {
            margin-bottom: 16px;
            color: #1a1a2e;
        }
        
        .modal p, .modal li {
            color: #555;
            line-height: 1.6;
            margin-bottom: 8px;
        }
        
        .modal ul {
            margin-left: 20px;
            margin-bottom: 20px;
        }
        
        .btn-primary {
            width: 100%;
            padding: 12px;
            background: #e94560;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .btn-primary:hover {
            background: #d63d56;
        }
        
        textarea.baseline-input {
            width: 100%;
            height: 150px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            margin: 16px 0;
            resize: vertical;
        }
        
        .source-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: #e3f2fd;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 6px;
            margin-bottom: 6px;
        }
        
        .source-tag button {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
        }
        
        .hidden { display: none !important; }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .app-container {
                grid-template-columns: 240px 1fr 280px;
            }
        }
        
        @media (max-width: 900px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: 60px auto 1fr auto;
            }
            .sidebar-left, .sidebar-right {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Onboarding Modal -->
    <div id="onboardingModal" class="modal active">
        <div class="modal-content">
            <h2>üéØ Writing Defense Platform</h2>
            <p>Phase 1 MVP - Research Grade Tool</p>
            <ul>
                <li><strong>Shadow System:</strong> Real-time AI detector emulation</li>
                <li><strong>Burstiness EKG:</strong> Visualize sentence variance</li>
                <li><strong>Stumble Detection:</strong> Track authentic writing pauses</li>
                <li><strong>Source Analysis:</strong> OCR + similarity detection</li>
                <li><strong>Baseline Calibration:</strong> Learn your authentic voice</li>
            </ul>
            <p style="font-size: 12px; color: #999; margin-top: 20px;">
                ‚ö†Ô∏è All data stays local in your browser. No server uploads.
            </p>
            <button class="btn-primary" onclick="closeOnboarding()">Get Started</button>
        </div>
    </div>

    <!-- Baseline Modal -->
    <div id="baselineModal" class="modal">
        <div class="modal-content">
            <h2>Baseline Calibration</h2>
            <p>Paste 1-3 samples of your previous writing (2000+ words recommended for 95% confidence).</p>
            <textarea id="baselineInput" class="baseline-input" placeholder="Paste your writing samples here to create your linguistic fingerprint..."></textarea>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                <span id="wordCount" style="font-size: 13px; color: #666;">0 words</span>
                <button class="btn-primary" style="width: auto; padding: 8px 24px;" onclick="createBaseline()">Create Baseline</button>
            </div>
            <p style="font-size: 11px; color: #999;">Your baseline helps detect voice drift and ensures authentic writing patterns.</p>
        </div>
    </div>

    <!-- Main App -->
    <div class="app-container">
        <header class="header">
            <div class="logo">
                <div class="logo-icon">W</div>
                <div>
                    <div style="font-weight: 700;">Writing Defense</div>
                    <div style="font-size: 11px; opacity: 0.8;">Phase 1 MVP</div>
                </div>
            </div>
            <div style="display: flex; gap: 16px; align-items: center;">
                <div id="baselineStatus" class="status-badge pending" onclick="showBaselineModal()">
                    ‚ö†Ô∏è No Baseline Set
                </div>
                <button onclick="exportCSV()" style="background: #16213e; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 13px;">
                    Export CSV
                </button>
            </div>
        </header>

        <aside class="sidebar-left">
            <div class="card">
                <h3>Baseline Profile</h3>
                <div id="baselineMetrics">
                    <p style="font-size: 13px; color: #666; font-style: italic;">
                        No baseline calibrated. Click "No Baseline Set" above to start.
                    </p>
                </div>
            </div>

            <div class="card">
                <h3>Source Files</h3>
                <div id="sourceList" style="margin-bottom: 12px;">
                    <p style="font-size: 12px; color: #999;">No sources loaded</p>
                </div>
                <label class="upload-area">
                    <input type="file" id="fileInput" accept=".txt,.pdf" onchange="handleFileUpload(event)">
                    <div style="font-size: 24px; margin-bottom: 8px;">üìÑ</div>
                    <div style="font-size: 13px; color: #666;">Drop PDF or TXT</div>
                    <div style="font-size: 11px; color: #999; margin-top: 4px;">Supports OCR for scanned PDFs</div>
                </label>
                <div id="ocrStatus" style="margin-top: 8px; font-size: 11px; color: #666; display: none;">
                    Processing OCR...
                </div>
            </div>

            <div class="card">
                <h3>Session Recovery</h3>
                <p style="font-size: 12px; color: #666; margin-bottom: 8px;">
                    Auto-saving every 30 seconds to browser storage.
                </p>
                <button onclick="loadAutoSave()" style="width: 100%; padding: 8px; background: #f0f0f0; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                    Restore Previous Session
                </button>
            </div>
        </aside>

        <main class="main-content">
            <div class="toolbar">
                <button onclick="formatText('bold')" title="Bold"><b>B</b></button>
                <button onclick="formatText('italic')" title="Italic"><i>I</i></button>
                <div style="width: 1px; height: 20px; background: #ddd; margin: 0 8px;"></div>
                <span id="docStats" style="font-size: 13px; color: #666;">0 words ‚Ä¢ 0 sentences</span>
            </div>
            
            <div class="editor-container">
                <div id="editor" contenteditable="true" oninput="handleInput(event)" onkeydown="handleKeyDown(event)" onpaste="handlePaste(event)"></div>
            </div>
        </main>

        <aside class="sidebar-right">
            <div class="card">
                <h3 style="display: flex; align-items: center; gap: 8px;">
                    <span style="width: 8px; height: 8px; background: #e94560; border-radius: 50%;"></span>
                    Shadow System
                    <span style="margin-left: auto; font-size: 11px; color: #999; font-weight: normal;">AI Detection Risk</span>
                </h3>
                
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span style="font-size: 12px; color: #666;">Current Risk</span>
                    <span id="currentRisk" class="metric-value success">0%</span>
                </div>
                
                <div class="progress-bar">
                    <div id="riskBar" class="progress-fill safe" style="width: 0%"></div>
                </div>
                
                <div class="shadow-chart" id="shadowChart">
                    <!-- Bars generated by JS -->
                </div>
                
                <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 10px; color: #999;">
                    <span>Safe</span>
                    <span>Caution</span>
                    <span>High Risk</span>
                </div>
            </div>

            <div class="card">
                <h3 style="display: flex; align-items: center; gap: 8px;">
                    <span style="width: 8px; height: 8px; background: #3b82f6; border-radius: 50%;"></span>
                    Burstiness EKG
                </h3>
                <div class="ekg-container">
                    <canvas id="ekgCanvas"></canvas>
                </div>
                <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 11px; color: #666;">
                    <span>Low variance</span>
                    <span style="font-weight: 600;" id="burstinessValue">0.00</span>
                    <span>High variance</span>
                </div>
            </div>

            <div class="card">
                <h3 style="display: flex; align-items: center; gap: 8px;">
                    <span style="width: 8px; height: 8px; background: #f9a825; border-radius: 50%;"></span>
                    Stumble System
                </h3>
                <div class="stumble-list" id="stumbleList">
                    <p style="font-style: italic; color: #999;">Start typing to detect cognitive pauses...</p>
                </div>
                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #f0f0f0;">
                    <div class="metric" style="padding: 0;">
                        <span style="font-size: 12px; color: #666;">Pauses detected</span>
                        <span id="pauseCount" class="metric-value" style="font-size: 16px;">0</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Real-time Metrics</h3>
                <div class="metric">
                    <span style="font-size: 13px; color: #555;">Lexical Diversity</span>
                    <span id="diversityValue" class="metric-value" style="font-size: 16px;">0.00</span>
                </div>
                <div class="metric">
                    <span style="font-size: 13px; color: #555;">Avg Sentence Length</span>
                    <span id="avgLengthValue" class="metric-value" style="font-size: 16px;">0</span>
                </div>
                <div class="metric">
                    <span style="font-size: 13px; color: #555;">Source Matches</span>
                    <span id="sourceMatches" class="metric-value" style="font-size: 16px;">0</span>
                </div>
            </div>
        </aside>
    </div>

    <!-- Alerts Container -->
    <div class="alerts-container" id="alerts"></div>

    <script>
        // ==================== STATE ====================
        let baseline = null;
        let sources = [];
        let keystrokes = [];
        let lastKeystrokeTime = Date.now();
        let stumbles = [];
        let sessionData = {
            text: '',
            sentences: [],
            metrics: []
        };
        let autoSaveInterval;

        // ==================== INITIALIZATION ====================
        window.onload = function() {
            loadFromStorage();
            initEKG();
            startAutoSave();
            
            // Focus editor
            setTimeout(() => {
                document.getElementById('editor').focus();
            }, 100);
        };

        // ==================== UI FUNCTIONS ====================
        function closeOnboarding() {
            document.getElementById('onboardingModal').classList.remove('active');
            if (!baseline) {
                showBaselineModal();
            }
        }

        function showBaselineModal() {
            document.getElementById('baselineModal').classList.add('active');
        }

        function closeBaselineModal() {
            document.getElementById('baselineModal').classList.remove('active');
        }

        function showAlert(message, type = 'info') {
            const container = document.getElementById('alerts');
            const alert = document.createElement('div');
            alert.className = `alert ${type}`;
            alert.textContent = message;
            container.appendChild(alert);
            
            setTimeout(() => {
                alert.style.opacity = '0';
                alert.style.transform = 'translateX(100%)';
                setTimeout(() => alert.remove(), 300);
            }, 4000);
        }

        // ==================== BASELINE ====================
        function createBaseline() {
            const text = document.getElementById('baselineInput').value;
            const wordCount = text.split(/\s+/).filter(w => w.length > 0).length;
            
            if (wordCount < 200) {
                alert('Please provide at least 200 words for accurate calibration.');
                return;
            }

            const sentences = tokenizeSentences(text);
            const wordLengths = sentences.map(s => s.split(' ').length);
            
            baseline = {
                wordCount: wordCount,
                sentenceCount: sentences.length,
                avgSentenceLength: wordLengths.reduce((a,b) => a+b, 0) / sentences.length,
                burstiness: calculateSD(wordLengths),
                lexicalDiversity: calculateDiversity(text),
                confidence: Math.min(100, (wordCount / 2000) * 100),
                createdAt: new Date().toISOString(),
                patterns: extractPatterns(text)
            };

            saveToStorage();
            closeBaselineModal();
            updateBaselineUI();
            showAlert('Baseline calibrated successfully!', 'success');
        }

        function updateBaselineUI() {
            const status = document.getElementById('baselineStatus');
            const metrics = document.getElementById('baselineMetrics');
            
            if (baseline) {
                status.textContent = `‚úì Baseline ${baseline.confidence.toFixed(0)}%`;
                status.className = 'status-badge ready';
                status.onclick = showBaselineModal;
                
                metrics.innerHTML = `
                    <div class="metric">
                        <span style="font-size: 12px; color: #666;">Words Analyzed</span>
                        <span style="font-weight: 600;">${baseline.wordCount}</span>
                    </div>
                    <div class="metric">
                        <span style="font-size: 12px; color: #666;">Confidence</span>
                        <span style="font-weight: 600; color: ${baseline.confidence > 80 ? '#16c79a' : '#f9a825'}">${baseline.confidence.toFixed(0)}%</span>
                    </div>
                    <div class="metric">
                        <span style="font-size: 12px; color: #666;">Avg Burstiness</span>
                        <span style="font-weight: 600;">${baseline.burstiness.toFixed(2)}</span>
                    </div>
                    <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #f0f0f0;">
                        <button onclick="showBaselineModal()" style="width: 100%; padding: 6px; background: #f0f0f0; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            Recalibrate
                        </button>
                    </div>
                `;
            }
        }

        // ==================== EDITOR ====================
        function handleInput(e) {
            const text = e.target.innerText || '';
            sessionData.text = text;
            
            const sentences = tokenizeSentences(text);
            sessionData.sentences = sentences;
            
            // Update stats
            const words = text.split(/\s+/).filter(w => w.length > 0).length;
            document.getElementById('docStats').textContent = `${words} words ‚Ä¢ ${sentences.length} sentences`;
            
            // Calculate metrics
            const burstiness = calculateBurstiness(sentences);
            const diversity = calculateDiversity(text);
            
            // Update UI
            document.getElementById('burstinessValue').textContent = burstiness.toFixed(2);
            document.getElementById('diversityValue').textContent = diversity.toFixed(2);
            
            const avgLen = sentences.length ? (words / sentences.length).toFixed(1) : 0;
            document.getElementById('avgLengthValue').textContent = avgLen;
            
            // Draw EKG
            drawEKG(sentences);
            
            // Update Shadow
            updateShadow(sentences);
            
            // Check source similarity
            checkSourceSimilarity(text);
            
            // Check voice drift
            if (baseline && sentences.length > 0) {
                const currentBurst = calculateBurstiness(sentences.slice(-3));
                if (Math.abs(currentBurst - baseline.burstiness) > 3) {
                    if (Math.random() > 0.7) showAlert('Voice drift detected: Style differs from baseline', 'warning');
                }
            }
        }

        function handleKeyDown(e) {
            const now = Date.now();
            const interval = now - lastKeystrokeTime;
            
            // Detect paste
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                showAlert('Paste detected - excluded from stumble analysis', 'info');
                return;
            }
            
            // Detect stumble (pause > 1.5 seconds, not first keystroke)
            if (interval > 1500 && sessionData.text.length > 10) {
                const stumble = {
                    time: now,
                    duration: interval,
                    position: sessionData.text.length,
                    sentence: sessionData.sentences.length
                };
                stumbles.push(stumble);
                updateStumbleUI();
                
                if (stumbles.length % 3 === 0) {
                    showAlert('Cognitive pause detected - indicates authentic writing', 'success');
                }
            }
            
            keystrokes.push({
                time: now,
                key: e.key,
                interval: interval
            });
            
            lastKeystrokeTime = now;
        }

        function handlePaste(e) {
            setTimeout(() => {
                handleInput({target: document.getElementById('editor')});
            }, 0);
        }

        function formatText(command) {
            document.execCommand(command, false, null);
            document.getElementById('editor').focus();
        }

        // ==================== SHADOW SYSTEM ====================
        function updateShadow(sentences) {
            const chart = document.getElementById('shadowChart');
            chart.innerHTML = '';
            
            if (sentences.length === 0) return;
            
            let totalRisk = 0;
            
            sentences.slice(-20).forEach((sentence, idx) => {
                const risk = calculateShadowScore(sentence);
                totalRisk += risk;
                
                const bar = document.createElement('div');
                bar.className = 'shadow-bar';
                
                if (risk > 0.7) bar.classList.add('high');
                else if (risk > 0.4) bar.classList.add('medium');
                else bar.classList.add('low');
                
                if (idx === sentences.slice(-20).length - 1) bar.classList.add('current');
                
                bar.style.height = `${Math.max(10, risk * 100)}%`;
                bar.title = `Sentence ${idx + 1}: ${(risk * 100).toFixed(0)}% risk`;
                
                chart.appendChild(bar);
            });
            
            const avgRisk = totalRisk / sentences.length;
            const riskPercent = (avgRisk * 100).toFixed(0);
            const riskEl = document.getElementById('currentRisk');
            const riskBar = document.getElementById('riskBar');
            
            riskEl.textContent = riskPercent + '%';
            riskBar.style.width = riskPercent + '%';
            
            if (avgRisk > 0.7) {
                riskEl.className = 'metric-value warning';
                riskBar.className = 'progress-fill';
            } else if (avgRisk > 0.4) {
                riskEl.className = 'metric-value caution';
                riskBar.className = 'progress-fill caution';
            } else {
                riskEl.className = 'metric-value success';
                riskBar.className = 'progress-fill safe';
            }
        }

        function calculateShadowScore(sentence) {
            const words = sentence.split(' ').filter(w => w.length > 0);
            if (words.length === 0) return 0.3;
            
            const avgLength = words.reduce((a, w) => a + w.length, 0) / words.length;
            const hasFormal = /\b(however|moreover|furthermore|consequently|therefore|thus)\b/i.test(sentence);
            const isUniform = Math.abs(words.length - 15) < 3; // Close to average
            
            let score = 0.3;
            if (avgLength > 5.5) score += 0.15;
            if (hasFormal) score += 0.1;
            if (isUniform) score += 0.1;
            if (words.length > 20) score += 0.1;
            
            // Add some noise for realism
            score += (Math.random() - 0.5) * 0.1;
            
            return Math.max(0, Math.min(1, score));
        }

        // ==================== STUMBLE SYSTEM ====================
        function updateStumbleUI() {
            const list = document.getElementById('stumbleList');
            const count = document.getElementById('pauseCount');
            
            count.textContent = stumbles.length;
            
            if (stumbles.length === 0) return;
            
            list.innerHTML = '';
            stumbles.slice(-5).reverse().forEach(stumble => {
                const div = document.createElement('div');
                div.className = 'stumble-item';
                div.innerHTML = `
                    <strong>${(stumble.duration / 1000).toFixed(1)}s pause</strong><br>
                    <span style="font-size: 11px; opacity: 0.8;">Sentence ${stumble.sentence}</span>
                `;
                list.appendChild(div);
            });
        }

        // ==================== EKG ====================
        function initEKG() {
            const canvas = document.getElementById('ekgCanvas');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }

        function drawEKG(sentences) {
            const canvas = document.getElementById('ekgCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            if (sentences.length < 2) return;
            
            const lengths = sentences.map(s => s.split(' ').length);
            const max = Math.max(...lengths);
            const min = Math.min(...lengths);
            const range = max - min || 1;
            
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.beginPath();
            
            const stepX = width / (lengths.length - 1);
            
            lengths.forEach((len, i) => {
                const x = i * stepX;
                const y = height - ((len - min) / range * (height - 10)) - 5;
                
                if (i === 0) ctx.moveTo(x, y);
                else {
                    const prevX = (i - 1) * stepX;
                    const prevY = height - ((lengths[i-1] - min) / range * (height - 10)) - 5;
                    const cpX = (prevX + x) / 2;
                    ctx.quadraticCurveTo(cpX, prevY, x, y);
                }
                
                // Draw point
                ctx.fillStyle = len > (max + min) / 2 ? '#f9a825' : '#16c79a';
                ctx.fillRect(x - 2, y - 2, 4, 4);
            });
            
            ctx.stroke();
        }

        // ==================== FILE UPLOAD ====================
        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const status = document.getElementById('ocrStatus');
            status.style.display = 'block';
            status.textContent = 'Processing...';
            
            if (file.type === 'application/pdf' || file.name.endsWith('.pdf')) {
                // Simulate OCR processing
                setTimeout(() => {
                    status.textContent = 'OCR Complete (simulated)';
                    const source = {
                        id: Date.now(),
                        name: file.name,
                        text: "Extracted text from PDF would appear here. In a full implementation, this would use Tesseract.js for OCR or pdf-lib for text extraction.",
                        type: 'pdf'
                    };
                    sources.push(source);
                    updateSourceUI();
                    showAlert('PDF processed (OCR simulation)', 'success');
                }, 1500);
            } else {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const source = {
                        id: Date.now(),
                        name: file.name,
                        text: e.target.result,
                        type: 'txt'
                    };
                    sources.push(source);
                    updateSourceUI();
                    status.style.display = 'none';
                    showAlert('Text file loaded successfully', 'success');
                };
                reader.readAsText(file);
            }
        }

        function updateSourceUI() {
            const list = document.getElementById('sourceList');
            
            if (sources.length === 0) {
                list.innerHTML = '<p style="font-size: 12px; color: #999;">No sources loaded</p>';
                return;
            }
            
            list.innerHTML = sources.map(s => `
                <div class="source-tag">
                    ${s.name}
                    <button onclick="removeSource(${s.id})">√ó</button>
                </div>
            `).join('');
        }

        function removeSource(id) {
            sources = sources.filter(s => s.id !== id);
            updateSourceUI();
        }

        function checkSourceSimilarity(text) {
            let matches = 0;
            const textLower = text.toLowerCase();
            
            sources.forEach(source => {
                const sourceSentences = tokenizeSentences(source.text);
                sourceSentences.forEach(sent => {
                    if (sent.length > 20 && textLower.includes(sent.toLowerCase().slice(0, 30))) {
                        matches++;
                    }
                });
            });
            
            document.getElementById('sourceMatches').textContent = matches;
            
            if (matches > 0 && matches % 3 === 0) {
                showAlert(`High similarity to source material detected (${matches} matches)`, 'warning');
            }
        }

        // ==================== EXPORT ====================
        function exportCSV() {
            const rows = [
                ['timestamp', 'sentence', 'burstiness', 'shadow_risk', 'stumble_count'].join(','),
                ...sessionData.sentences.map((sent, i) => [
                    new Date().toISOString(),
                    `"${sent.replace(/"/g, '""')}"`,
                    calculateBurstiness([sent]),
                    calculateShadowScore(sent),
                    stumbles.filter(s => s.sentence === i).length
                ].join(','))
            ].join('\n');
            
            downloadFile(rows, 'text/csv', `writing_defense_${new Date().toISOString().split('T')[0]}.csv`);
            showAlert('CSV exported successfully', 'success');
        }

        function downloadFile(content, type, filename) {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ==================== STORAGE ====================
        function startAutoSave() {
            autoSaveInterval = setInterval(() => {
                if (sessionData.text.length > 0) {
                    localStorage.setItem('writingDefense_autosave', JSON.stringify({
                        html: document.getElementById('editor').innerHTML,
                        text: sessionData.text,
                        timestamp: Date.now(),
                        stumbles: stumbles,
                        keystrokes: keystrokes.length
                    }));
                }
            }, 30000);
        }

        function loadAutoSave() {
            const saved = localStorage.getItem('writingDefense_autosave');
            if (saved) {
                const data = JSON.parse(saved);
                if (confirm(`Restore session from ${new Date(data.timestamp).toLocaleTimeString()}?`)) {
                    document.getElementById('editor').innerHTML = data.html;
                    sessionData.text = data.text;
                    stumbles = data.stumbles || [];
                    handleInput({target: document.getElementById('editor')});
                    updateStumbleUI();
                    showAlert('Session restored', 'success');
                }
            } else {
                showAlert('No previous session found', 'info');
            }
        }

        function saveToStorage() {
            localStorage.setItem('writingDefense_baseline', JSON.stringify(baseline));
            localStorage.setItem('writingDefense_sources', JSON.stringify(sources));
        }

        function loadFromStorage() {
            const savedBaseline = localStorage.getItem('writingDefense_baseline');
            const savedSources = localStorage.getItem('writingDefense_sources');
            
            if (savedBaseline) {
                baseline = JSON.parse(savedBaseline);
                updateBaselineUI();
            }
            
            if (savedSources) {
                sources = JSON.parse(savedSources);
                updateSourceUI();
            }
        }

        // ==================== MATH UTILS ====================
        function tokenizeSentences(text) {
            return text.replace(/([.!?])\s+/g, "$1|").split("|").filter(s => s.trim().length > 0);
        }

        function calculateBurstiness(sentences) {
            if (sentences.length < 2) return 0;
            const lengths = sentences.map(s => s.split(' ').length);
            return calculateSD(lengths);
        }

        function calculateSD(values) {
            if (values.length === 0) return 0;
            const mean = values.reduce((a,b) => a+b, 0) / values.length;
            const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / values.length;
            return Math.sqrt(variance);
        }

        function calculateDiversity(text) {
            const words = text.toLowerCase().match(/\b[a-z]+\b/g) || [];
            if (words.length === 0) return 0;
            const unique = new Set(words);
            return unique.size / words.length;
        }

        function extractPatterns(text) {
            // Simplified pattern extraction
            return {
                avgWordLength: text.length / (text.split(' ').length || 1),
                punctuationDensity: (text.match(/[.!?,:;]/g) || []).length / text.length
            };
        }

        // Handle window resize for EKG
        window.addEventListener('resize', () => {
            initEKG();
            if (sessionData.sentences.length > 0) {
                drawEKG(sessionData.sentences);
            }
        });
    </script>
</body>
</html>
