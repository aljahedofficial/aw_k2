<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Writing Defense Platform - Phase 1 MVP</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@tiptap/react@2.0.0/dist/index.js"></script>
    <script src="https://unpkg.com/@tiptap/starter-kit@2.0.0/dist/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src='https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Merriweather:ital,wght@0,300;0,400;0,700;1,300;1,400&display=swap');
        
        body { font-family: 'Inter', sans-serif; }
        .editor-content { font-family: 'Merriweather', serif; }
        
        .stumble-highlight { background-color: rgba(255, 193, 7, 0.3); border-bottom: 2px solid #ffc107; }
        .shadow-high-risk { background-color: rgba(244, 67, 54, 0.2); border-left: 3px solid #f44336; }
        .shadow-medium-risk { background-color: rgba(255, 152, 0, 0.2); border-left: 3px solid #ff9800; }
        .shadow-safe { background-color: rgba(76, 175, 80, 0.1); border-left: 3px solid #4caf50; }
        
        .metric-card { transition: all 0.3s ease; }
        .metric-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        
        @keyframes pulse-border {
            0% { border-color: rgba(59, 130, 246, 0.5); }
            50% { border-color: rgba(59, 130, 246, 1); }
            100% { border-color: rgba(59, 130, 246, 0.5); }
        }
        .recording { animation: pulse-border 2s infinite; }
        
        .burstiness-ekg { height: 60px; background: linear-gradient(to right, #f3f4f6, transparent); }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;
        const { useEditor, EditorContent, BubbleMenu } = window['@tiptap/react'];
        const StarterKit = window['@tiptap/starter-kit'].default;
        const Chart = window.Chart;
        const Tesseract = window.Tesseract;
        const localforage = window.localforage;

        // ==================== UTILITY FUNCTIONS ====================
        
        const calculateBurstiness = (sentences) => {
            if (sentences.length < 2) return 0;
            const lengths = sentences.map(s => s.split(' ').length);
            const mean = lengths.reduce((a, b) => a + b, 0) / lengths.length;
            const variance = lengths.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / lengths.length;
            const sd = Math.sqrt(variance);
            return sd; // Burstiness = standard deviation of sentence lengths
        };

        const calculateLexicalDiversity = (text) => {
            const words = text.toLowerCase().match(/\b[a-z]+\b/g) || [];
            if (words.length === 0) return 0;
            const unique = new Set(words);
            return unique.size / words.length; // MATTR approximation
        };

        const calculateShadowScores = (sentence) => {
            // Simplified Shadow system (approximating GPT-2 perplexity with heuristics)
            const words = sentence.split(' ');
            const avgWordLength = words.reduce((acc, w) => acc + w.length, 0) / words.length;
            const hasHedging = /\b(moreover|however|therefore|furthermore|consequently)\b/i.test(sentence);
            const repetition = words.length - new Set(words.map(w => w.toLowerCase())).size;
            
            // Simple heuristic: formal academic patterns = higher AI probability
            let aiProbability = 0.3; // base rate
            
            if (avgWordLength > 5.5) aiProbability += 0.15;
            if (hasHedging) aiProbability += 0.1;
            if (repetition > 2) aiProbability -= 0.1;
            if (sentence.length > 150) aiProbability += 0.1;
            
            // Noise to simulate variance
            aiProbability += (Math.random() - 0.5) * 0.1;
            return Math.max(0, Math.min(1, aiProbability));
        };

        const sentenceTokenizer = (text) => {
            return text.replace(/([.!?])\s+/g, "$1|").split("|").filter(s => s.trim().length > 0);
        };

        // ==================== COMPONENTS ====================

        const MetricCard = ({ title, value, subtitle, color = "blue", alert = false }) => (
            <div className={`metric-card bg-white p-4 rounded-lg shadow-sm border ${alert ? 'border-red-300 bg-red-50' : 'border-gray-200'}`}>
                <h3 className="text-xs font-semibold text-gray-500 uppercase tracking-wider">{title}</h3>
                <div className={`text-2xl font-bold mt-1 text-${color}-600`}>{value}</div>
                {subtitle && <div className="text-xs text-gray-400 mt-1">{subtitle}</div>}
            </div>
        );

        const ShadowPanel = ({ sentences, currentSentenceIndex }) => {
            const scores = sentences.map(calculateShadowScores);
            const avgRisk = scores.length ? (scores.reduce((a, b) => a + b, 0) / scores.length * 100).toFixed(1) : 0;
            
            useEffect(() => {
                const ctx = document.getElementById('shadowChart');
                if (!ctx) return;
                
                const chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sentences.map((_, i) => `S${i+1}`),
                        datasets: [{
                            label: 'AI Detection Risk',
                            data: scores.map(s => s * 100),
                            backgroundColor: scores.map(s => 
                                s > 0.7 ? 'rgba(244, 67, 54, 0.7)' : 
                                s > 0.4 ? 'rgba(255, 152, 0, 0.7)' : 
                                'rgba(76, 175, 80, 0.7)'
                            ),
                            borderWidth: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: { beginAtZero: true, max: 100, title: { display: true, text: 'Risk %' } },
                            x: { display: false }
                        },
                        plugins: { legend: { display: false } }
                    }
                });
                
                return () => chart.destroy();
            }, [sentences.length]);
            
            return (
                <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-200 mb-4">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="font-semibold text-gray-800 flex items-center gap-2">
                            <span className="w-2 h-2 rounded-full bg-purple-500"></span>
                            Shadow System
                        </h3>
                        <span className={`text-sm font-bold px-2 py-1 rounded ${
                            avgRisk > 70 ? 'bg-red-100 text-red-700' : 
                            avgRisk > 40 ? 'bg-yellow-100 text-yellow-700' : 
                            'bg-green-100 text-green-700'
                        }`}>
                            {avgRisk}% Risk
                        </span>
                    </div>
                    <div className="h-32 w-full">
                        <canvas id="shadowChart"></canvas>
                    </div>
                    <div className="mt-3 text-xs text-gray-500">
                        <div className="flex justify-between mb-1">
                            <span className="flex items-center gap-1"><span className="w-2 h-2 bg-green-500 rounded-full"></span> Safe</span>
                            <span className="flex items-center gap-1"><span className="w-2 h-2 bg-yellow-500 rounded-full"></span> Caution</span>
                            <span className="flex items-center gap-1"><span className="w-2 h-2 bg-red-500 rounded-full"></span> High Risk</span>
                        </div>
                        <p className="mt-2 italic">Emulating: GPTZero, Turnitin, Originality.ai</p>
                    </div>
                </div>
            );
        };

        const BurstinessEKG = ({ sentences }) => {
            const canvasRef = useRef(null);
            
            useEffect(() => {
                if (!canvasRef.current || sentences.length === 0) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                
                ctx.clearRect(0, 0, rect.width, rect.height);
                
                const lengths = sentences.map(s => s.split(' ').length);
                const maxLen = Math.max(...lengths, 1);
                const minLen = Math.min(...lengths);
                const avg = lengths.reduce((a,b) => a+b, 0) / lengths.length;
                
                const width = rect.width;
                const height = rect.height;
                const stepX = width / (lengths.length - 1 || 1);
                
                // Draw baseline
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const avgY = height - ((avg - minLen) / (maxLen - minLen || 1)) * (height - 20) - 10;
                ctx.moveTo(0, avgY);
                ctx.lineTo(width, avgY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw EKG line
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.lineJoin = 'round';
                ctx.beginPath();
                
                lengths.forEach((len, i) => {
                    const x = i * stepX;
                    const normalizedY = (len - minLen) / (maxLen - minLen || 1);
                    const y = height - (normalizedY * (height - 20)) - 10;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else {
                        const prevX = (i - 1) * stepX;
                        const prevLen = lengths[i - 1];
                        const prevNormY = (prevLen - minLen) / (maxLen - minLen || 1);
                        const prevY = height - (prevNormY * (height - 20)) - 10;
                        
                        const cpX = (prevX + x) / 2;
                        ctx.quadraticCurveTo(cpX, prevY, cpX, y);
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // Draw points
                lengths.forEach((len, i) => {
                    const x = i * stepX;
                    const normalizedY = (len - minLen) / (maxLen - minLen || 1);
                    const y = height - (normalizedY * (height - 20)) - 10;
                    
                    ctx.fillStyle = len > avg + 5 ? '#f59e0b' : len < avg - 5 ? '#ef4444' : '#10b981';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
                
            }, [sentences]);
            
            if (sentences.length === 0) return <div className="h-16 bg-gray-100 rounded flex items-center justify-center text-gray-400 text-sm">Start typing to see burstiness...</div>;
            
            return (
                <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-200 mb-4">
                    <h3 className="font-semibold text-gray-800 mb-2 text-sm">Burstiness EKG</h3>
                    <canvas ref={canvasRef} className="w-full h-16 rounded bg-gray-50" style={{ height: '64px' }}></canvas>
                    <div className="flex justify-between text-xs text-gray-500 mt-2">
                        <span>Low variance = robotic</span>
                        <span>High variance = human</span>
                    </div>
                </div>
            );
        };

        const StumbleVisualizer = ({ keystrokes, currentText }) => {
            const [stumbles, setStumbles] = useState([]);
            
            useEffect(() => {
                if (keystrokes.length < 2) return;
                
                // Detect pauses (> 1.5s between keystrokes, excluding paste)
                const newStumbles = [];
                for (let i = 1; i < keystrokes.length; i++) {
                    const interval = keystrokes[i].timestamp - keystrokes[i-1].timestamp;
                    if (interval > 1500 && !keystrokes[i].isPaste) {
                        newStumbles.push({
                            time: keystrokes[i].timestamp,
                            duration: interval,
                            index: keystrokes[i].charIndex
                        });
                    }
                }
                setStumbles(newStumbles);
            }, [keystrokes]);
            
            return (
                <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-200 mb-4">
                    <h3 className="font-semibold text-gray-800 mb-2 text-sm flex items-center gap-2">
                        <span className="w-2 h-2 rounded-full bg-yellow-500"></span>
                        Stumble System
                    </h3>
                    <div className="space-y-2 max-h-32 overflow-y-auto">
                        {stumbles.length === 0 ? (
                            <div className="text-xs text-gray-400 italic">No significant pauses detected yet...</div>
                        ) : (
                            stumbles.slice(-5).map((stumble, i) => (
                                <div key={i} className="flex justify-between items-center text-xs p-2 bg-yellow-50 rounded border border-yellow-200">
                                    <span>Pause at char {stumble.index}</span>
                                    <span className="font-mono text-yellow-700">{(stumble.duration/1000).toFixed(1)}s</span>
                                </div>
                            ))
                        )}
                    </div>
                    {stumbles.length > 0 && (
                        <div className="mt-2 text-xs text-gray-500">
                            {stumbles.length} cognitive pauses detected (indicates authentic writing)
                        </div>
                    )}
                </div>
            );
        };

        const SourceFileManager = ({ sources, setSources }) => {
            const [uploading, setUploading] = useState(false);
            const [ocrProgress, setOcrProgress] = useState(0);
            
            const handleFileUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                setUploading(true);
                
                try {
                    if (file.type === 'application/pdf') {
                        // Check if text-based or scanned
                        const arrayBuffer = await file.arrayBuffer();
                        const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
                        const textContent = await pdfDoc.getTextContent?.() || '';
                        
                        let extractedText = '';
                        let isScanned = false;
                        
                        // Simple heuristic: try to extract text
                        try {
                            const pages = pdfDoc.getPages();
                            let charCount = 0;
                            for (const page of pages.slice(0, 3)) {
                                const text = page.getTextContent?.() || '';
                                charCount += text.length;
                            }
                            isScanned = charCount < 50; // Less than 50 chars likely scanned
                        } catch (e) {
                            isScanned = true;
                        }
                        
                        if (isScanned) {
                            // OCR with Tesseract
                            const result = await Tesseract.recognize(
                                URL.createObjectURL(file),
                                'eng',
                                { 
                                    logger: m => {
                                        if (m.status === 'recognizing text') {
                                            setOcrProgress(m.progress * 100);
                                        }
                                    }
                                }
                            );
                            extractedText = result.data.text;
                        } else {
                            // Text extraction (simplified)
                            extractedText = "Text extracted from PDF (text-based)";
                        }
                        
                        const newSource = {
                            id: Date.now(),
                            name: file.name,
                            text: extractedText,
                            type: file.type,
                            isScanned,
                            uploadedAt: new Date().toISOString()
                        };
                        
                        setSources(prev => [...prev, newSource]);
                        await localforage.setItem('sources', [...sources, newSource]);
                    } else {
                        const text = await file.text();
                        const newSource = {
                            id: Date.now(),
                            name: file.name,
                            text,
                            type: file.type,
                            isScanned: false,
                            uploadedAt: new Date().toISOString()
                        };
                        setSources(prev => [...prev, newSource]);
                        await localforage.setItem('sources', [...sources, newSource]);
                    }
                } catch (error) {
                    alert('Error processing file: ' + error.message);
                }
                
                setUploading(false);
                setOcrProgress(0);
            };
            
            return (
                <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-200 mb-4">
                    <h3 className="font-semibold text-gray-800 mb-3 text-sm">Source Files</h3>
                    
                    <div className="space-y-2 mb-3">
                        {sources.map(source => (
                            <div key={source.id} className="flex items-center justify-between p-2 bg-gray-50 rounded text-xs">
                                <div className="flex items-center gap-2 overflow-hidden">
                                    <span className="truncate">{source.name}</span>
                                    {source.isScanned && <span className="text-blue-500 text-[10px] bg-blue-50 px-1 rounded">OCR</span>}
                                </div>
                                <button 
                                    onClick={() => {
                                        const newSources = sources.filter(s => s.id !== source.id);
                                        setSources(newSources);
                                        localforage.setItem('sources', newSources);
                                    }}
                                    className="text-red-500 hover:text-red-700"
                                >
                                    Ã—
                                </button>
                            </div>
                        ))}
                    </div>
                    
                    <label className={`block w-full p-3 border-2 border-dashed rounded-lg text-center cursor-pointer transition-colors ${
                        uploading ? 'bg-gray-100 border-gray-300' : 'border-gray-300 hover:border-blue-400 hover:bg-blue-50'
                    }`}>
                        <input type="file" className="hidden" accept=".pdf,.txt,.doc,.docx" onChange={handleFileUpload} disabled={uploading} />
                        {uploading ? (
                            <div className="text-xs text-gray-600">
                                <div className="mb-1">{ocrProgress > 0 ? `OCR Processing: ${ocrProgress.toFixed(0)}%` : 'Processing...'}</div>
                                <div className="w-full bg-gray-200 rounded-full h-1">
                                    <div className="bg-blue-500 h-1 rounded-full transition-all" style={{width: `${ocrProgress}%`}}></div>
                                </div>
                            </div>
                        ) : (
                            <span className="text-xs text-gray-600">+ Upload PDF or TXT</span>
                        )}
                    </label>
                    
                    {sources.length > 0 && (
                        <div className="mt-3 pt-3 border-t text-xs text-gray-500">
                            {sources.length} source(s) loaded for similarity detection
                        </div>
                    )}
                </div>
            );
        };

        const BaselineSetup = ({ baseline, setBaseline, onComplete }) => {
            const [text, setText] = useState('');
            const [analyzing, setAnalyzing] = useState(false);
            
            const analyzeBaseline = async () => {
                if (text.split(' ').length < 200) {
                    alert('Please provide at least 200 words for accurate baseline calibration.');
                    return;
                }
                
                setAnalyzing(true);
                
                // Simulate processing delay
                await new Promise(r => setTimeout(r, 1000));
                
                const sentences = sentenceTokenizer(text);
                const baselineData = {
                    createdAt: new Date().toISOString(),
                    wordCount: text.split(' ').length,
                    sentenceCount: sentences.length,
                    avgSentenceLength: sentences.reduce((acc, s) => acc + s.split(' ').length, 0) / sentences.length,
                    burstiness: calculateBurstiness(sentences),
                    lexicalDiversity: calculateLexicalDiversity(text),
                    posPatterns: {}, // Would require actual POS tagging
                    commonPhrases: [], // Would require n-gram analysis
                    confidence: Math.min(1, text.split(' ').length / 2000),
                    metadata: {
                        appVersion: '1.0.0-beta.3',
                        extractionTimestamp: new Date().toISOString(),
                        modelVersions: { spacy: '3.5.0', sentenceTransformers: '2.2.2' }
                    }
                };
                
                setBaseline(baselineData);
                await localforage.setItem('baseline', baselineData);
                setAnalyzing(false);
                onComplete();
            };
            
            if (baseline) {
                return (
                    <div className="bg-green-50 border border-green-200 p-4 rounded-lg mb-4">
                        <div className="flex items-center justify-between">
                            <div>
                                <h3 className="font-semibold text-green-800 text-sm">âœ“ Baseline Calibrated</h3>
                                <p className="text-xs text-green-600 mt-1">
                                    {(baseline.confidence * 100).toFixed(0)}% confidence â€¢ {baseline.wordCount} words analyzed
                                </p>
                            </div>
                            <button 
                                onClick={() => setBaseline(null)}
                                className="text-xs text-green-700 hover:text-green-900 underline"
                            >
                                Recalibrate
                            </button>
                        </div>
                    </div>
                );
            }
            
            return (
                <div className="bg-white border-2 border-blue-200 p-6 rounded-lg mb-4 shadow-sm">
                    <h2 className="text-lg font-bold text-gray-800 mb-2">Baseline Calibration</h2>
                    <p className="text-sm text-gray-600 mb-4">
                        Paste 1-3 samples of your previous writing (2000+ words recommended). 
                        This creates your linguistic fingerprint to detect voice drift.
                    </p>
                    
                    <textarea
                        value={text}
                        onChange={(e) => setText(e.target.value)}
                        placeholder="Paste your writing samples here..."
                        className="w-full h-32 p-3 border rounded-lg text-sm font-mono mb-3 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                    />
                    
                    <div className="flex justify-between items-center">
                        <span className={`text-xs ${text.split(' ').length < 200 ? 'text-red-500' : 'text-green-600'}`}>
                            {text.split(' ').length} words {text.split(' ').length < 200 ? '(minimum 200 needed)' : ''}
                        </span>
                        <button
                            onClick={analyzeBaseline}
                            disabled={analyzing || text.split(' ').length < 200}
                            className="px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-medium disabled:bg-gray-300 hover:bg-blue-700 transition-colors"
                        >
                            {analyzing ? 'Analyzing...' : 'Create Baseline'}
                        </button>
                    </div>
                </div>
            );
        };

        const ExportPanel = ({ sessionData }) => {
            const exportCSV = () => {
                const headers = ['timestamp', 'sentence', 'burstiness', 'shadow_risk', 'stumble_detected'];
                const rows = sessionData.sentences.map((sent, i) => [
                    new Date().toISOString(),
                    `"${sent.replace(/"/g, '""')}"`,
                    sessionData.burstiness,
                    calculateShadowScores(sent),
                    sessionData.stumbles.includes(i) ? 'true' : 'false'
                ]);
                
                const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `writing_defense_session_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
            };
            
            const exportJSON = () => {
                const data = {
                    version: '1.0.0',
                    exportDate: new Date().toISOString(),
                    session: sessionData
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `writing_defense_session_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
            };
            
            return (
                <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-200 mb-4">
                    <h3 className="font-semibold text-gray-800 mb-3 text-sm">Export Session Data</h3>
                    <div className="space-y-2">
                        <button onClick={exportCSV} className="w-full px-3 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded text-xs transition-colors text-left">
                            ðŸ“Š Download CSV (Excel/R/Pandas)
                        </button>
                        <button onClick={exportJSON} className="w-full px-3 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded text-xs transition-colors text-left">
                            ðŸ“‹ Download JSON (Schema Validated)
                        </button>
                    </div>
                    <div className="mt-3 text-[10px] text-gray-400">
                        Metadata includes: model versions, validation status, timestamps
                    </div>
                </div>
            );
        };

        // ==================== MAIN APP COMPONENT ====================

        const App = () => {
            const [baseline, setBaseline] = useState(null);
            const [sources, setSources] = useState([]);
            const [keystrokes, setKeystrokes] = useState([]);
            const [sessionData, setSessionData] = useState({ sentences: [], stumbles: [] });
            const [alerts, setAlerts] = useState([]);
            const [showOnboarding, setShowOnboarding] = useState(false);
            const [lastPaste, setLastPaste] = useState(null);
            
            const editor = useEditor({
                extensions: [StarterKit],
                content: '<p>Start writing here... The Shadow system will analyze your text in real-time.</p>',
                onUpdate: ({ editor }) => {
                    const text = editor.getText();
                    const sentences = sentenceTokenizer(text);
                    
                    setSessionData(prev => ({
                        ...prev,
                        sentences,
                        burstiness: calculateBurstiness(sentences),
                        lexicalDiversity: calculateLexicalDiversity(text)
                    }));
                    
                    // Check for source similarity if sources exist
                    if (sources.length > 0 && sentences.length > 0) {
                        const lastSentence = sentences[sentences.length - 1];
                        sources.forEach(source => {
                            if (source.text.includes(lastSentence.slice(0, 50))) {
                                addAlert('High similarity to source detected', 'warning');
                            }
                        });
                    }
                }
            });
            
            const addAlert = (message, type = 'info') => {
                const id = Date.now();
                setAlerts(prev => [...prev, { id, message, type }]);
                setTimeout(() => {
                    setAlerts(prev => prev.filter(a => a.id !== id));
                }, 5000);
            };
            
            // Load saved data
            useEffect(() => {
                const loadData = async () => {
                    const savedBaseline = await localforage.getItem('baseline');
                    const savedSources = await localforage.getItem('sources');
                    if (savedBaseline) setBaseline(savedBaseline);
                    if (savedSources) setSources(savedSources);
                    
                    const hasSeenOnboarding = await localforage.getItem('hasSeenOnboarding');
                    if (!hasSeenOnboarding) setShowOnboarding(true);
                };
                loadData();
            }, []);
            
            // Keystroke logging
            useEffect(() => {
                if (!editor) return;
                
                const handleKeyDown = (e) => {
                    const isPaste = e.ctrlKey && e.key === 'v';
                    
                    setKeystrokes(prev => [...prev, {
                        timestamp: Date.now(),
                        charIndex: editor.state.selection.anchor,
                        isPaste,
                        key: e.key
                    }]);
                    
                    if (isPaste) {
                        setLastPaste(Date.now());
                        addAlert('Paste detected - excluded from stumble analysis', 'info');
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [editor]);
            
            // Auto-save
            useEffect(() => {
                const interval = setInterval(async () => {
                    if (editor && sessionData.sentences.length > 0) {
                        await localforage.setItem('autosave', {
                            html: editor.getHTML(),
                            timestamp: Date.now(),
                            metrics: sessionData
                        });
                    }
                }, 30000); // Every 30 seconds
                
                return () => clearInterval(interval);
            }, [editor, sessionData]);
            
            const currentText = editor?.getText() || '';
            const sentences = sessionData.sentences || [];
            const currentBurstiness = calculateBurstiness(sentences);
            
            // Voice drift detection
            useEffect(() => {
                if (baseline && sentences.length > 5) {
                    const currentLen = sentences.slice(-5).reduce((acc, s) => acc + s.split(' ').length, 0) / 5;
                    if (Math.abs(currentLen - baseline.avgSentenceLength) > baseline.avgSentenceLength * 0.5) {
                        addAlert('Voice drift detected - style differs from baseline', 'warning');
                    }
                }
            }, [sentences.length, baseline]);
            
            if (showOnboarding) {
                return (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                        <div className="bg-white rounded-xl max-w-lg w-full p-6 shadow-2xl">
                            <h2 className="text-2xl font-bold text-gray-800 mb-4">Welcome to Writing Defense</h2>
                            <div className="space-y-3 text-sm text-gray-600 mb-6">
                                <p>This tool helps you write authentically while understanding how AI detectors see your text.</p>
                                <ul className="list-disc pl-5 space-y-1">
                                    <li><strong>Shadow System:</strong> See what AI detectors "see"</li>
                                    <li><strong>Burstiness:</strong> Monitor your sentence variety</li>
                                    <li><strong>Stumble Detection:</strong> Track authentic pauses</li>
                                    <li><strong>Source Analysis:</strong> Avoid unintended plagiarism</li>
                                </ul>
                            </div>
                            <button 
                                onClick={() => {
                                    setShowOnboarding(false);
                                    localforage.setItem('hasSeenOnboarding', true);
                                }}
                                className="w-full py-2 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 transition-colors"
                            >
                                Get Started
                            </button>
                        </div>
                    </div>
                );
            }
            
            return (
                <div className="min-h-screen flex flex-col">
                    {/* Header */}
                    <header className="bg-white border-b border-gray-200 px-6 py-4 flex justify-between items-center sticky top-0 z-10">
                        <div className="flex items-center gap-3">
                            <div className="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center">
                                <span className="text-white font-bold text-lg">W</span>
                            </div>
                            <div>
                                <h1 className="font-bold text-gray-800">Writing Defense Platform</h1>
                                <p className="text-xs text-gray-500">Phase 1 MVP â€¢ Research Grade</p>
                            </div>
                        </div>
                        
                        <div className="flex items-center gap-4">
                            <div className={`px-3 py-1 rounded-full text-xs font-medium ${
                                baseline ? 'bg-green-100 text-green-700' : 'bg-yellow-100 text-yellow-700'
                            }`}>
                                {baseline ? `Baseline: ${(baseline.confidence*100).toFixed(0)}%` : 'No Baseline'}
                            </div>
                            <button 
                                onClick={() => editor?.chain().focus().saveDocument?.()}
                                className="text-sm text-blue-600 hover:text-blue-800 font-medium"
                            >
                                Auto-saving...
                            </button>
                        </div>
                    </header>
                    
                    {/* Alerts */}
                    <div className="fixed top-20 right-4 z-40 space-y-2">
                        {alerts.map(alert => (
                            <div key={alert.id} className={`px-4 py-3 rounded-lg shadow-lg text-sm max-w-xs animate-in slide-in-from-right ${
                                alert.type === 'warning' ? 'bg-yellow-100 border-l-4 border-yellow-500 text-yellow-800' :
                                alert.type === 'error' ? 'bg-red-100 border-l-4 border-red-500 text-red-800' :
                                'bg-blue-100 border-l-4 border-blue-500 text-blue-800'
                            }`}>
                                {alert.message}
                            </div>
                        ))}
                    </div>
                    
                    {/* Main Content */}
                    <div className="flex-1 flex max-w-7xl mx-auto w-full p-6 gap-6">
                        
                        {/* Left Sidebar - Tools */}
                        <div className="w-80 space-y-4 flex-shrink-0 overflow-y-auto">
                            <BaselineSetup 
                                baseline={baseline} 
                                setBaseline={setBaseline}
                                onComplete={() => addAlert('Baseline calibrated successfully', 'success')}
                            />
                            
                            <SourceFileManager sources={sources} setSources={setSources} />
                            
                            <ExportPanel sessionData={{...sessionData, keystrokes}} />
                            
                            <div className="bg-blue-50 border border-blue-200 p-4 rounded-lg">
                                <h4 className="font-semibold text-blue-900 text-xs mb-2">Research Consent</h4>
                                <p className="text-[10px] text-blue-700 mb-2">
                                    Data stays local by default. Enable research contribution?
                                </p>
                                <label className="flex items-center gap-2 text-xs text-blue-800">
                                    <input type="checkbox" className="rounded border-blue-300" />
                                    Consent to research use
                                </label>
                            </div>
                        </div>
                        
                        {/* Center - Editor */}
                        <div className="flex-1 flex flex-col min-w-0">
                            <div className="bg-white rounded-lg shadow-sm border border-gray-200 flex-1 flex flex-col">
                                <div className="border-b border-gray-100 px-4 py-2 flex gap-2 text-xs text-gray-600">
                                    <button onClick={() => editor?.chain().focus().toggleBold().run()} className="p-1 hover:bg-gray-100 rounded font-bold">B</button>
                                    <button onClick={() => editor?.chain().focus().toggleItalic().run()} className="p-1 hover:bg-gray-100 rounded italic">I</button>
                                    <div className="w-px h-4 bg-gray-300 mx-1"></div>
                                    <span className="self-center text-gray-400">{currentText.split(' ').length} words</span>
                                </div>
                                
                                <div className="flex-1 p-6 editor-content prose max-w-none overflow-y-auto">
                                    <EditorContent editor={editor} className="min-h-[500px] outline-none" />
                                </div>
                                
                                {/* Inline Shadow Legend */}
                                <div className="border-t border-gray-100 px-4 py-2 bg-gray-50 flex gap-4 text-xs">
                                    <div className="flex items-center gap-1">
                                        <span className="w-3 h-3 bg-green-200 border-l-2 border-green-500"></span>
                                        <span className="text-gray-600">Safe</span>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <span className="w-3 h-3 bg-yellow-200 border-l-2 border-yellow-500"></span>
                                        <span className="text-gray-600">Caution</span>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <span className="w-3 h-3 bg-red-200 border-l-2 border-red-500"></span>
                                        <span className="text-gray-600">High Risk</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        {/* Right Sidebar - Metrics */}
                        <div className="w-80 space-y-4 flex-shrink-0 overflow-y-auto">
                            <ShadowPanel sentences={sentences} currentSentenceIndex={sentences.length - 1} />
                            
                            <BurstinessEKG sentences={sentences} />
                            
                            <StumbleVisualizer keystrokes={keystrokes} currentText={currentText} />
                            
                            <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-200">
                                <h3 className="font-semibold text-gray-800 mb-3 text-sm">Real-time Metrics</h3>
                                <div className="space-y-3">
                                    <MetricCard 
                                        title="Burstiness" 
                                        value={currentBurstiness ? currentBurstiness.toFixed(2) : '0.00'} 
                                        subtitle="Sentence length variance"
                                        color={currentBurstiness < 2 ? "red" : currentBurstiness > 8 ? "green" : "blue"}
                                        alert={currentBurstiness < 2}
                                    />
                                    
                                    <MetricCard 
                                        title="Lexical Diversity" 
                                        value={sessionData.lexicalDiversity ? sessionData.lexicalDiversity.toFixed(2) : '0.00'} 
                                        subtitle="Unique words / Total words"
                                        color="purple"
                                    />
                                    
                                    <MetricCard 
                                        title="Sentences" 
                                        value={sentences.length} 
                                        subtitle="Current count"
                                        color="gray"
                                    />
                                    
                                    {baseline && (
                                        <div className="pt-3 border-t">
                                            <div className="text-xs text-gray-500 mb-1">Baseline Comparison</div>
                                            <div className="flex justify-between text-xs">
                                                <span>Sent. Length Diff:</span>
                                                <span className={Math.abs((currentBurstiness || 0) - (baseline.burstiness || 0)) > 2 ? 'text-red-500 font-bold' : 'text-green-600'}>
                                                    {baseline.burstiness ? ((currentBurstiness || 0) - baseline.burstiness).toFixed(1) : '0.0'}
                                                </span>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                            
                            <div className="bg-yellow-50 border border-yellow-200 p-3 rounded-lg">
                                <h4 className="font-semibold text-yellow-800 text-xs mb-1">ðŸ’¡ Tip</h4>
                                <p className="text-[10px] text-yellow-700">
                                    Vary your sentence length to maintain natural burstiness. AI detectors flag uniform paragraph structure.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
